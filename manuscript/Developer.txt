# As a Developer...

## As a Developer I need to manage multiple development environments.

> *Dear JVM Guy, at my company people wear many hats and work on a variety of projects.  I find myself constantly struggling to modify 
> modify my laptop to suit the needs of my current project.  Its a nightmare to get the right JDK versions of
> JDK, Ruby, Python and MySQL.  Please help!*
>
> *Constantly Switching in Cairo*

**The JVM Guy Recommends: VirtualBox, Linux, Packer, Vagrant, Ansible**

Dear Constantly Switching, I've been where you are and I think I can help. All you need to do is stop using your real
box for development and switch to a virtualized environment.  The free hypervisor VirtualBox is an excellent tool that I have been successfully 
using for many years.  Using virtualization allows you to quickly switch between project setups without having to modify your real machine.  Howevever,
before you can switch to a virtualized environment you'll have to pick up a few technologies. 

A> ## Using Linux as your development OS
A>
A> Do I have to ditch Windows for Linux?  In a word -- yes.  It's not that Windows is bad, its just that tooling works so much better
A> with Linux than Windows.  In addition, it has been my experience that many applications are deployed to virtualized Linux 
A> environments in production so why not develop the skills to work with those servers by experiencing Linux as you develop?

VirtualBox allows you to run almost any operating system you want but somebody still has to install the OS and applications.  That is where 
Vagrant comes in.  Vagrant understands VirtualBox's command-line tools and orchestrates the installation of the OS and applications.  It does so
by loading what Vagrant calls a base box. A base box is an image of a pre-configured OS usually pulled down from Vagrant's registry in
the cloud.  I, however, prefer to create my own base box configured just the way I want.  Luckily, that process can be automated as well using
Packer.  Tweaking the base box for particular environments, such as installing IntelliJ or a JDK can also be automated using the Ansible
provisioner.  Let's put all these tools to work.

A> ## Using VirtualBox as the hypervisor
A>
A> Is VirtualBox my only option? Absolutely not.  You can use any hypervisor you have access to, such as VMWare, but you probably want to 
A> check the Vagrant documentation and verify that your hypervisor is supported.  The same can be said for Ansible.  If you are more
A> comfortable with Salt, Puppet or Chef then use one of those tools.  The tool chain isn't what is important -- the use of virtualization
A> is.

**Using Packer To Create Custom Vagrant Base Boxes**

To recap, the goal is to create a tuned development environment using as much automation as possible.  The first step is to create 
a base box that can be used as the base for our development environments.  The base box I like to use is built upon Xubuntu 14.04 and Docker.

The Packer documentation does a good job explaining how to set things up so I'll concentrate on the major pieces. First up is the Packer
template file.  It is a JSON file that tells Packer where to grab the OS image to boot up and what provisioners to run against the 
running machine.

{title="Packer Template File: trusty-x64-desktop.json", lang="JavaScript"} 
<<(packer/trusty-x64-desktop.json)

The Packer documentation is well written so I won't go into great detail here about the file format but I will highlight items that took me some
research to figure out how to do.  First order of business -- how to actually get Ubuntu installed in automated fashion?  Typically, the Ubuntu installation process
is interactive with a human at the keyboard answering various questions. Obviously, if you want Packer to automate the process you cannot require human 
interaction.  Fortunately, Ubuntu supports the notion of a `preseed` file which contains all the answers to the installer's questions.  All you have to
do is to get Packer to tell the installer to use the preseed file.  That is what all of that odd looking text in the `boot_command` section is.  That text
is what a human would have to type in order to get the installer to perform an automated installation.

Another interesting section of the Packer template file is the `provisioners` section.  Here we are running a few shell scripts using the `sudo` command
to make the box Vagrant friendly.  The contents of the scripts are uninteresting and can be viewed on the website so look there if you are curious about
the details. The takeaway is that we're installing Ansible into the image.   Next, notice the second block in the `provisioners` section alaunches the Ansible  
provisioning tool.  In a nutshell, Ansible
allows you to script your provisioning commands and execute them over SSH.  Very easy to set up and extremely useful. Normally, you run Ansible on a single machine 
on the network and have it SSH out to any boxes
that need provisioning.  Since we are using Vagrant, we want everything to be self-contained which is why Ansible is installed into the image.

{title="Ansible Installation Script: install-ansible.sh", lang="Bash"} 
<<(packer/ansible/scripts/install-ansible.sh)

You dictate to Ansible what the desired state of the machine should be and let Ansible figure out how to make that happen.  The desired state is described in
what is known as a `playbook` which is a YAML file that references the numerous Ansible modules available to it.  Custom logic can be
encapsulated in simple shell scripts or, if you want to share your logic with others, in a custom Ansible module.  One thing to note is that any custom logic
you write should be created in such a way as to make the steps idempotent.  The baked-in Ansible modules are idempotent and won't do anything if the desired
state is already in place.  Your logic should follow the same pattern.  I didn't do this my first time out and I ended up with 50 duplicate entries in an `/etc/hosts` 
file!

{title="Ansible Playbook (desktop): ansible-desktop.yml", lang="YAML"} 
<<(packer/ansible/ansible-desktop.yml)

This playbook is very simple and installs a handful of packages suitable for a desktop.  Depending on what you decide to install, provisioning can take several
minutes and is typically dictated by your network connection speeds.  Ansible is an extremely powerful tool and we will be using
much more of in when build our custom environments.  To be complete, here is the playbook for our headless boxes.  You'll notice that it is almost identical
to the desktop playbook but installs a slightly different set of packages.

{title="Ansible Playbook (server): ansible-server.yml", lang="YAML"} 
<<(packer/ansible/ansible-server.yml)

Before we can use our base boxes we must have Packer build them and then install them into Vagrant's cache of boxes.  I normally script this
process so I don't fat finger something.

{title="Desktop Build Script: build-trusty-desktop.sh", lang="Bash"} 
<<(packer/build-trusty-desktop.sh)

{title="Server Build Script: packer/build-trusty-server.sh", lang="Bash"} 
<<(packer/packer/build-trusty-server.sh)

T> ## Testing configurations can take lots of time
T>
T> Developing the recipe for your particular base boxes involves a lot of trial and error which means executing lots of failed builds.  Each build
T> can take quite a while as you wait for ISOs to be downloaded and spun up.  Doing this on a laptop while sitting on the couch chatting with family
T> was how I killed time between builds.  Make sure you have a distraction or two lined up as you go through this process.  Once you have your recipe
T> set up the way you like it, regenerating base boxes will be much simpler and more predictable.

D> ## How much should I bake into my base boxes?
D>
D> It depends on how varied the environments you will be building are.  If you know that only minor customizations
D> are required in your VMs then it might make sense to put all of the common parts into the base box.  That could add up to huge time savings later on
D> because creating your VMs will be quicker due to the small amount of provisioning required.  If your projects are like mine, which vary to a
D> fairly wide degree, it might be safer to keep the base box to a bare minimum and tolerate provision times.  There is no law that says you can only
D> have one or two base boxes.  Once you get the hang of Packer you might find it to your advantage to have base boxes for family of solutions.

**Using Vagrant To Build Our Development Environment**
**Using Ansible To Provision Our Development Environment**

## As a Developer I want to be able to quickly create a skeleton for my new micro-service project

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Recommends: lazybones**

## As a Developer I want to quickly bootstrap my new micro-service project

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Solution: Spring Boot**

## As a Developer I want to be able to easily create unit tests

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Recommends: Spock**

## As a Developer I want to be able to easily create components tests

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Recommends: Spock, Spring Test**

## As a Developer I want to my code automatically inspected for style violations and bad practices

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Recommends: CodeNarc**

## As a Developer I want to automatically detect missing unit tests for new code

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Recommends: JaCoCo**

## As a Developer I want to run component test against fake services

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Recommends: betamax, Spring Profiles**

## As a Developer I want to add features to the main branch without breaking the system

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Recommends: feature toggles, branch by abstraction, Spring Profiles**

## As a Developer I want to document my micro-service's REST APIs

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Recommends: Swagger**

## As a Developer I want to document my micro-service's relational database schema

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Recommends: SchemaSpy**

## As a Developer I want to document my micro-service's class relationships

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Recommends: UMLGraph (check Neal's talk)**

## As a Developer I want to keep my logic adaptive to change

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Recommends: Spring Integration**

## As a Developer I want my code changes automatically built

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Recommends: Jenkins, Bamboo**

## As a Developer I want my artifacts automatically made available

> *Dear JVM Guy, ...*
>
> Sleepless in Seattle

**The JVM Guy Recommends: Artifactory, bintray**
