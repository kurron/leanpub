# Build Pipeline
This section of the book may be the most important.  Why?  It is here where we lay the foundation for building our software in a highly automated fashion.
It has been my experience that any manual step will eventually get dropped from the process.  At best, it will be sporadically applied, avoiding the consistency
you need to see real benefits.

T> If you find yourself performing the same task for a third time, stop and find a way to automate it.  It could be as simple as Bash script that
T> moves files from one place to another or as complex as re-configuring your load balancer to point to a different group of servers.  Leaving something
T> done frequently as a manual process is an invitation for a mistake to be made, and mistakes slow you down.

The build pipeline refers to all the steps required to go from Groovy source code to a deployed artifact.  The primary goal is to automate as much as possible.
I'm talking code reviews, testing, documentation, all of it.  Let the computer do the boring, routine stuff leaving the more complex decisions to humans.
People get tired, bored and distracted.  Computers don't so use them.

## Gradle
My build tool of choice is [Gradle](http://www.gradle.org/).  It is a powerful tool that is simple to understand and easy to customize.  It consists of an expressive
Domain Specific Language and numerous plug-ins. Unlike Ant and Maven, which can restrict what can easily be expressed, you have full access to the Groovy
programming language and the entire JVM ecosystem to solve any problem.  In a nutshell, Gradle is a great tool and you should take advantage of it.

T> ## GVM
T> Although I'll show you how to set up your builds so that Gradle does not have to be installed on a development machine, you will need to bootstrap
T> yourself initially.  One nice tool to do that is the [Groovy enVironment Manager](http://gvmtool.net/) or GVM for short.  It manages the procurement and
T> installation of a variety of useful tools, including:
T>
T>* [crash](http://www.crashub.org/)
T>* [gaiden](https://github.com/kobo/gaiden)
T>* [glide](http://glide-gae.appspot.com/)
T>* [gradle](http://www.gradle.org/)
T>* [grails](https://grails.org/)
T>* [griffon](http://griffon.codehaus.org/)
T>* [groovy](http://groovy.codehaus.org/)
T>* [groovyserv](http://kobo.github.io/groovyserv/)
T>* [lazybones](https://github.com/pledbrook/lazybones)
T>* [springboot](http://projects.spring.io/spring-boot/)
T>* [vertx](http://vertx.io/)
T>
T> GVM knows when an update has been released and can apply the update to your system, if desired.

## Project File Structure
Despite the fact that I'm not a huge [Maven](http://maven.apache.org/) fan, I must give kudos to the team for providing the JVM world with
two defacto standards: dependency management and project file structure.  Having a standard directory layout makes it much easier on
humans and programs to locate files and resources.  Convention over configuration makes life a little simpler.

Gradle is highly configurable but defaults to the Maven project layout.  The Maven standard looks like this:

| src/main/java      | application sources                                                        |
| src/main/resources | application resources                                                      |
| src/main/filters   | resource filter files                                                      |
| src/main/config    | configuration files                                                        |
| src/main/scripts   | application scripts                                                        |
| src/main/webapp    | web application sources                                                    |
| src/test/java      | test sources                                                               |
| src/test/resources | test resources                                                             |
| src/test/filters   | test resource filter files                                                 |
| src/it             | integration tests                                                          |
| src/assembly       | assembly descriptors                                                       |
| src/site           | project web site                                                           |
| LICENSE.txt        | project's license                                                          |
| NOTICE.txt         | notices and attributions required by libraries that the project depends on |
| README.txt         | project's readme                                                           |

As you can see, this is an intelligent layout and can work with most applications.  We'll be using a slightly smaller sub-set for our projects but,
for the most part, the names and definitions of the directories will match the above list.

To create our example project, we'll use a simple script.

<<[new-project.sh](pipeline/src/main/scripts/new-project.sh)

If we run `./new-project /tmp/hello` we should end up with a skeleton directory structure.

Obviously, a more sophisticated script would copy template Gradle files from a central location but this is good
enough to get us started.

## Build Stages
The build process we're creating is normally used in two contexts.  The first context is the developer.  She wants
her source compiled, packaged up and unit tested.  The second context is the Continuous Integration (CI) server, aka
the build box.  The CI server, in addition to performing the same tasks in the developer context, will also execute
integration tests and perform more time consuming inspections.  Finally, the CI server will make the resulting
artifacts available to the next stage in the pipeline.  We'll discuss additional stages later in the book.

### Stage One: Developer
This stage is meant to give quick feedback to the developer and plays the role of watchdog.  "Did you put your
braces in the correct spot?"  "Did you write a unit test for that new class?"  "Is that new algorithm too complex?"
If your build process provides this kind of feedback you will find that even the most junior member of your
team can have a positive impact on the project.  There will be less need for rework due to some obvious standards
violation allowing humans to focus on the more complex and interesting parts of the review.

W> ## Keep The Build Short
W> Try and keep your stage one builds to under 2 minutes.  Anything longer than that and people will hesitate
W> to run the build.  If the build gets too long that could be an indication that you are building something larger
W> than a micro-service, aka another ball of mud.  The rule we have on my teams is that you can code as much as
W> you want in your IDE but you *must* run the Gradle build before pushing code to the repository.  That way,
W> people still get the desired feedback but don't feel constrained by the tooling.

## Stage One
Since Gradle is primary a DSL written in Groovy, you can treat your build script as a mini-program, complete
with conditionals and iteration constructs.  We'll take advantage of this by splitting our build file into
two halves: one for each stage.  The default stage will be one and is the one that be will be run the most.

<<[build.gradle](pipeline/build.gradle)

Let's examine the individual pieces of the build file.

{crop-start-line=1,crop-end-line=25}
<<[preamble](pipeline/build.gradle)
This section of the file establishes some properties that hold the version numbers for some of the libraries
we depend on.   Secondly, it declares where on the network we should look to download missing dependencies.
Finally, it declares a dependency on the Spring Boot plug-in, which we'll discuss in detail in another chapter.
You'll notice that we're excluding the `commons-logging` library.  That library has served its purpose and
we prefer the more modern `sl4j` and `logback` combination but some dependencies insist on dragging it in.

{crop-start-line=26,crop-end-line=30}
<<[Conditional Build Logic](pipeline/build.gradle)

Here we are getting a little more sophisticated and checking the value of the `stage` property to see which
section of the `if` statement we need to execute.  One question you might be asking yourself is "where is the
property declared?"  That is a good question with an easy answer: `gradle.properties`.

<<[gradle.properties](pipeline/gradle.properties)

For reasons I don't fully understand, if you want to create a property that can be overridden on the command-line,
like we do, then you have to put it in the `gradle.properties` file.  By controlling the `stage` property, we
can run stage one by default and have the CI server run stage two.  To control the build stage, all you have to
do is add an additional flag on the command-line:

|`./gradlew`             | stage one is run|
|`./gradlew -Pstage=one` | stage one is run|
|`./gradlew -Pstage=two` | stage two is run|

Obviously, you could expand this idea to support as many stages as you need but we'll stick with two for now.

### Plug-Ins
Gradle is driven primarily by plug-ins which encapsulate combinations of behavior into a single, configurable
package.  We'll examine the plug-ins I like to include and delve into why they are important.

{crop-start-line=27,crop-end-line=37}
<<[plug-in section](pipeline/build.gradle)

The **Groovy plug-in** is the workhorse of the bunch and the one we count on the most.  It is responsible for
compiling the code, generating documentation, running unit-tests and packaging everything up into deployable
artifacts.  It also has the capability to do joint compilation so if you have a mixture of Java and Groovy
code in your project this plug-in can handle both languages.

The **WAR plug-in** creates a web archive instead of a standard JAR.  I'll explain it later in detail but be aware
that we are creating a web application despite the fact that we aren't creating any web pages.  We're using a web
container to stand up the application as well as provide for HTTP-based monitoring and control.

The **CodeNarc plug-in** is one of those tools that you will love to hate.  Its job is be your personal code
reviewer. It looks for formatting issues, methods that are too large or complex.  My favorite feature is that
it can recommend 'Groovyier' ways of writing code.  Regardless of whether your team is just starting out with
Groovy or are seasoned veterans, this plug-in can save your team from wasting time on silly mistakes.

T> ### Inspection of Test Code
T> CodeNarc gives you the option of not inspecting test code.  I've worked on projects where CodeNarc only
T> inspected the production code and I've regretted the decision.  What happens is that the test code isn't given
T> the same amount of respect the production code is and you run into the typical issues -- duplicate code,
T> code brittle to change, duplicate code, all the usual bad stuff.  My suggestion is to have CodeNarc inspect
T> **everything** and use selective overrides as needed.  You'll be glad you did.
T>

### Application Plugin
### Codenarc Plugin
### Checkstyle Plugin
### Findbugs Plugin
### JDepend Plugin
### PMD Plugin
### Project Report Plugin
### Sonar Plugin
### Jacoco Plugin

### Stage One

### Stage Two

## Jenkins

## Artifactory

## Virtual Box




 