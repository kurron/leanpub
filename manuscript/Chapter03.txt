# Build Pipeline
This section of the book may be the most important.  Why?  It is here where we lay the foundation for building our software in a highly automated fashion.
It has been my experience that any manual step will eventually get dropped from the process.  At best, it will be sporadically applied, avoiding the consistency
you need to see real benefits.

T> If you find yourself performing the same task for a third time, stop and find a way to automate it.  It could be as simple as Bash script that
T> moves files from one place to another or as complex as re-configuring your load balancer to point to a different group of servers.  Leaving something
T> done frequently as a manual process is an invitation for a mistake to be made, and mistakes slow you down.

The build pipeline refers to all the steps required to go from Groovy source code to a deployed artifact.  The primary goal is to automate as much as possible.
I'm talking code reviews, testing, documentation, all of it.  Let the computer do the boring, routine stuff leaving the more complex decisions to humans.
People get tired, bored and distracted.  Computers don't so use them.

## Gradle
My build tool of choice is [Gradle](http://www.gradle.org/).  It is a powerful tool that is simple to understand and easy to customize.  It consists of an expressive
Domain Specific Language and numerous plug-ins. Unlike Ant and Maven, which can restrict what can easily be expressed, you have full access to the Groovy
programming language and the entire JVM ecosystem to solve any problem.  In a nutshell, Gradle is a great tool and you should take advantage of it.

T> ## GVM
T> Although I'll show you how to set up your builds so that Gradle does not have to be installed on a development machine, you will need to bootstrap
T> yourself initially.  One nice tool to do that is the [Groovy enVironment Manager](http://gvmtool.net/) or GVM for short.  It manages the procurement and
T> installation of a variety of useful tools, including:
T>
T>* [crash](http://www.crashub.org/)
T>* [gaiden](https://github.com/kobo/gaiden)
T>* [glide](http://glide-gae.appspot.com/)
T>* [gradle](http://www.gradle.org/)
T>* [grails](https://grails.org/)
T>* [griffon](http://griffon.codehaus.org/)
T>* [groovy](http://groovy.codehaus.org/)
T>* [groovyserv](http://kobo.github.io/groovyserv/)
T>* [lazybones](https://github.com/pledbrook/lazybones)
T>* [springboot](http://projects.spring.io/spring-boot/)
T>* [vertx](http://vertx.io/)
T>
T> GVM knows when an update has been released and can apply the update to your system, if desired.

## Project File Structure
Despite the fact that I'm not a huge [Maven](http://maven.apache.org/) fan, I must give kudos to the team for providing the JVM world with
two defacto standards: dependency management and project file structure.  Having a standard directory layout makes it much easier on
humans and programs to locate files and resources.  Convention over configuration makes life a little simpler.

Gradle is highly configurable but defaults to the Maven project layout.  The Maven standard looks like this:

| src/main/java      | application sources                                                        |
| src/main/resources | application resources                                                      |
| src/main/filters   | resource filter files                                                      |
| src/main/config    | configuration files                                                        |
| src/main/scripts   | application scripts                                                        |
| src/main/webapp    | web application sources                                                    |
| src/test/java      | test sources                                                               |
| src/test/resources | test resources                                                             |
| src/test/filters   | test resource filter files                                                 |
| src/it             | integration tests                                                          |
| src/assembly       | assembly descriptors                                                       |
| src/site           | project web site                                                           |
| LICENSE.txt        | project's license                                                          |
| NOTICE.txt         | notices and attributions required by libraries that the project depends on |
| README.txt         | project's readme                                                           |

As you can see, this is an intelligent layout and can work with most applications.  We'll be using a slightly smaller sub-set for our projects but,
for the most part, the names and definitions of the directories will match the above list.

To create our example project, we'll use a simple script.

<<[new-project.sh](pipeline/src/main/scripts/new-project.sh)

If we run `./new-project /tmp/hello` we should end up with a skeleton directory structure.

Obviously, a more sophisticated script would copy template Gradle files from a central location but this is good
enough to get us started.

## Build Stages
The build process we're creating is normally used in two contexts.  The first context is the developer.  She wants
her source compiled, packaged up and unit tested.  The second context is the Continuous Integration (CI) server, aka
the build box.  The CI server, in addition to performing the same tasks in the developer context, will also execute
integration tests and perform more time consuming inspections.  Finally, the CI server will make the resulting
artifacts available to the next stage in the pipeline.  We'll discuss additional stages later in the book.

### Stage One: Developer
This stage is meant to give quick feedback to the developer and plays the role of watchdog.  "Did you put your
braces in the correct spot?"  "Did you write a unit test for that new class?"  "Is that new algorithm too complex?"
If your build process provides this kind of feedback you will find that even the most junior member of your
team can have a positive impact on the project.  There will be less need for rework due to some obvious standards
violation allowing humans to focus on the more complex and interesting parts of the review.

W> ## Keep The Build Short
W> Try and keep your stage one builds to under 2 minutes.  Anything longer than that and people will hesitate
W> to run the build.  If the build gets too long that could be an indication that you are building something larger
W> than a micro-service, aka another ball of mud.  The rule we have on my teams is that you can code as much as
W> you want in your IDE but you *must* run the Gradle build before pushing code to the repository.  That way,
W> people still get the desired feedback but don't feel constrained by the tooling.

## Stage One
### Groovy Plugin
### Application Plugin
### WAR Plugin
### Codenarc Plugin
### Checkstyle Plugin
### Findbugs Plugin
### JDepend Plugin
### PMD Plugin
### Project Report Plugin
### Sonar Plugin
### Jacoco Plugin

### Stage One

### Stage Two

## Jenkins

## Artifactory

## Virtual Box




 